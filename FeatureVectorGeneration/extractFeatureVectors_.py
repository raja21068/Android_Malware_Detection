from xml.etree.ElementTree import ElementTree
import glob
import subprocess
import os
import codecs
import math
import multiprocessing
import hashlib
from multiprocessing.pool import Pool
import numpy as np
import distances
import time

taskParam_syslistfilename = 'dangerSys.txt'
taskParam_oplistfilename = 'ArmOpcodes.txt'
taskParam_apklistfilename = './apklist.txt'
taskParam_bytecodelistfilename = 'Bytecodes.txt'
taskParam_apilistfilename = 'dangerAPIs.txt'
taskParam_Arffdirname = "./Arff/"
taskParam_rawdatadirname = "./RawData(3000)/"
taskParam_noProcesses = 1
taskParam_Totaldirname = "./"
taskParam_methodminmax = "./"
taskParam_funcminmax = "./"
seglevel1 = 150
seglevel2 = 150

def getTotalUPS(tups):
    f = open(taskParam_Totaldirname+'F1_UPS_mani.txt','r')
    for line in f.readlines():
        tups.add(line[:-1])

def getTotalUCS(tucs):
    f = open(taskParam_Totaldirname+'F2_UCS_mani.txt','r')
    for line in f.readlines():
        tucs.add(line[:-1])

def getTotalUFS(tufs):
    f = open(taskParam_Totaldirname+'F3_UFS_mani.txt','r')
    for line in f.readlines():
        tufs.add(line[:-1])

def getTotalULS(tuls):
    f = open(taskParam_Totaldirname+'F4_ULS_mani.txt','r')
    for line in f.readlines():
        tuls.add(line[:-1])

def getTotalDPS(tdps):
    f = open(taskParam_Totaldirname+'F5_DPS_mani.txt','r')
    for line in f.readlines():
        tdps.add(line[:-1])

def getTotalUSS(tuss):
    f = open(taskParam_Totaldirname+'F6_USS_mani.txt','r')
    for line in f.readlines():
        tuss.add(line[:-1])

def getTotalACT(tact):
    f = open(taskParam_Totaldirname+'F7_ACT_mani.txt','r')
    for line in f.readlines():
        tact.add(line[:-1])

def getTotalSERV(tserv):
    f = open(taskParam_Totaldirname+'F8_SERV_mani.txt','r')
    for line in f.readlines():
        tserv.add(line[:-1])

def getTotalPROV(tprov):
    f = open(taskParam_Totaldirname+'F9_PROV_mani.txt','r')
    for line in f.readlines():
        tprov.add(line[:-1])

def getTotalRECV(trecv):
    f = open(taskParam_Totaldirname+'F10_RECV_mani.txt','r')
    for line in f.readlines():
        trecv.add(line[:-1])

def getTotalSTR(tstr):
    f = open(taskParam_Totaldirname+'F11_STR_smali.txt','r')
    for line in f.readlines():
        tstr.add(int(line[:-1],16)%10000)

def getTotalMETHOD_OP(tmethOP):
    f = open(taskParam_Totaldirname+'F12_METHOD_smali_OP.txt','r')
    flagcount = 0
    for line in f.readlines():
        s = line.split()
        v = list()
        for e in s:
            v.append(float(e))
        tmethOP.add(tuple(v))

def getTotalMETHOD_API(tmethAPI):
    f = open(taskParam_Totaldirname+'F12_METHOD_smali_API.txt','r')
    flagcount = 0
    for line in f.readlines():
        s = line.split()
        v = list()
        for e in s:
            v.append(float(e))
        tmethAPI.add(tuple(v))

def getTotalFUNC_OP(tfuncOP):
    f = open(taskParam_Totaldirname+'F13_FUNCTIONS_so_OP.txt','r')
    flagcount = 0
    for line in f.readlines():
        s = line.split()
        v = list()
        for e in s:
            v.append(float(e))
        tfuncOP.add(tuple(v))

def getTotalFUNC_SYS(tfuncSYS):
    f = open(taskParam_Totaldirname+'F13_FUNCTIONS_so_SYS.txt','r')
    flagcount = 0
    for line in f.readlines():
        s = line.split()
        v = list()
        for e in s:
            v.append(float(e))
        tfuncSYS.add(tuple(v))

def getIGTopKs(k):

    fmanifestIG = open('ig_manifest.txt','r')
    templist = fmanifestIG.readlines()[:k-1]
    manifestTopKs = list()
    for l in templist:
        manifestTopKs.append(int(l.split()[1])-1)
    fmanifestIG.close()

    fstringIG = open('ig_string.txt','r')
    templist = fstringIG.readlines()[:k-1]
    stringTopKs = list()
    for l in templist:
        stringTopKs.append(int(l.split()[1])-1)
    fstringIG.close()

    fmethodOPIG = open('ig_methodOP.txt','r')
    templist = fmethodOPIG.readlines()[:k-1]
    methodOPTopKs = list()
    for l in templist:
        methodOPTopKs.append(int(l.split()[1])-1)
    fmethodOPIG.close()

    fmethodAPIIG = open('ig_methodAPI.txt','r')
    templist = fmethodAPIIG.readlines()[:k-1]
    methodAPITopKs = list()
    for l in templist:
        methodAPITopKs.append(int(l.split()[1])-1)
    fmethodAPIIG.close()

    ffunctionOPIG = open('ig_functionOP.txt','r')
    templist = ffunctionOPIG.readlines()[:k-1]
    functionOPTopKs = list()
    for l in templist:
        functionOPTopKs.append(int(l.split()[1])-1)
    ffunctionOPIG.close()

    return manifestTopKs, stringTopKs,  methodOPTopKs, methodAPITopKs, functionOPTopKs


def logRaws(manifestTopKs, stringTopKs,  methodOPTopKs, methodAPITopKs, functionOPTopKs):

    tUPset = set()
    tUCset = set()
    tUFset = set()
    tULset = set()
    tDPset = set()
    tUSset = set()
    tACTset = set()
    tSERVset = set()
    tPROVset = set()
    tRECVset = set()
    tConstStringSet = set()
    tMethodOPSet = set() 
    tMethodAPISet = set()
    tFuncOPSet = set() 
    tFuncSYSSet = set()
    #later
    getTotalFeatSets(tUPset, tUCset, tUFset, tULset, tDPset, tUSset, tACTset, tSERVset, tPROVset, tRECVset, tConstStringSet, tMethodOPSet, tMethodAPISet, tFuncOPSet, tFuncSYSSet) 

    manifest = list()
    for item in tUPset:
        manifest.append(item)
    for item in tUCset:
        manifest.append(item)
    for item in tUFset:
        manifest.append(item)
    for item in tULset:
        manifest.append(item)
    for item in tDPset:
        manifest.append(item)
    for item in tUSset:
        manifest.append(item)
    for item in tACTset:
        manifest.append(item)
    for item in tSERVset:
        manifest.append(item)
    for item in tPROVset:
        manifest.append(item)
    for item in tRECVset:
        manifest.append(item)

    string = list()
    for item in tConstStringSet:
        string.append(str(item))
    
    methodOP = list()
    for item in tMethodOPSet: 
        methodOP.append((item))

    methodAPI = list()
    for item in tMethodAPISet: 
        methodAPI.append((item))
    
    functionOP = list()        
    for item in tFuncOPSet:
        functionOP.append((item))
    # later ...
    funtionSYS = list()        
    for item in tFuncSYSSet:
        funtionSYS.append((item))

    dslist = list()
    getSysList(taskParam_syslistfilename, dslist)
    dalist = list()
    getAPIList(taskParam_apilistfilename, dalist)
    bytelist = list()
    getBytecodelist(taskParam_bytecodelistfilename,bytelist)
    oplist = list()
    getArmOplist(taskParam_oplistfilename,oplist)

    fstingReal = open('F11_STR_smali_nHash.txt','r')
    strdict4hash = dict()
    for line in fstingReal.readlines():
        strdict4hash[line[:-1]] = int(hashlib.sha512(line[:-1]).hexdigest(),16)%10000
    fstingReal.close()

    fmanifest = open('manifestTopKs.txt','w')
    for index in manifestTopKs:
        fmanifest.write(str(manifest[index]))
        fmanifest.write('\n')
    fmanifest.close()

    fstring = open('stringTopKs.txt','w')
    for index in stringTopKs:
        temp = list()
        for key in strdict4hash.keys():
            
            if float(strdict4hash[key]) == float(string[index]):
                temp.append(key)
        fstring.write(str(temp))
        fstring.write('\n')
    fstring.close()

    fmethodOP = open('methodOPTopKs.txt','w')
    for index in methodOPTopKs:
        temp = dict()
        for i in range(len(methodOP[index])):
            if not methodOP[index][i] == 0.0:
                temp[bytelist[i]] = methodOP[index][i] 
        fmethodOP.write(str(temp))
        fmethodOP.write('\n')
    fmethodOP.close()

    fmethodAPI = open('methodAPITopKs.txt','w')
    for index in methodAPITopKs:
        temp = dict()
        for i in range(len(methodAPI[index])):
            if not methodAPI[index][i] == 0.0:
                temp[dalist[i]] = methodAPI[index][i] 
        fmethodAPI.write(str(temp))
        fmethodAPI.write('\n')
    fmethodAPI.close()

    ffunctionOP = open('functionOPTopKs.txt','w')
    for index in functionOPTopKs:
        temp = dict()
        for i in range(len(functionOP[index])):
            if not functionOP[index][i] == 0.0:
                temp[oplist[i]] = functionOP[index][i] 
        ffunctionOP.write(str(temp))
        ffunctionOP.write('\n')
    ffunctionOP.close()


def getRawsofTopKs(k):
    manifestTopKs, stringTopKs,  methodOPTopKs, methodAPITopKs, functionOPTopKs = getIGTopKs(k)
    logRaws(manifestTopKs, stringTopKs,  methodOPTopKs, methodAPITopKs, functionOPTopKs)

def getTotalFeatSets(tups, tucs, tufs, tuls, tdps, tuss, tact, tserv, tprov, trecv, tstr, tmethOP, tmethAPI, tfuncOP, tfuncSYS):

    getTotalUPS(tups)
    getTotalUCS(tucs)
    getTotalUFS(tufs)
    getTotalULS(tuls)
    getTotalDPS(tdps)
    getTotalUSS(tuss)
    getTotalACT(tact)
    getTotalSERV(tserv)
    getTotalPROV(tprov)
    getTotalRECV(trecv)
    getTotalSTR(tstr)
    getTotalMETHOD_OP(tmethOP)
    getTotalMETHOD_API(tmethAPI)
    getTotalFUNC_OP(tfuncOP)
    getTotalFUNC_SYS(tfuncSYS)
    
def gpu_euclidean_distance(X, Y):
    return distances.euclidean_distances([X],[Y],False)[0][0]

def gpu_euclidean_distances_wrapper_naive(X, Y):
    return distances.euclidean_distances(X,Y,False)

def gpu_euclidean_distances_wrapper(X, Y, segsize):

    xrow = len(X)
    yrow = len(Y)

    hdists = np.zeros(xrow*yrow)
    hdists = np.reshape(hdists,(xrow,yrow))

    for i in range(len(X)/segsize):
        for j in range(len(Y)/segsize):
            d = distances.euclidean_distances(X[i*segsize:(i+1)*segsize],Y[j*segsize:(j+1)*segsize],False)
            for rd in range(len(d)):
                for cd in range(len(d[0])):
                    #if d[rd][cd] < 0.000001 or d[rd][cd] == float('nan'):
                        #d[rd][cd] = distances.euclidean_distances([X[i*segsize+rd]],[Y[j*segsize+cd]],False)[0][0]
                        #d[rd][cd] = cpu_euclidean_distances(X[i*segsize+rd],Y[j*segsize+cd])
                    hdists[i*segsize+rd][j*segsize+cd] = d[rd][cd]
        
        d = distances.euclidean_distances(X[i*segsize:(i+1)*segsize],Y[len(Y)-len(Y)%segsize:len(Y)],False)
        for rd in range(len(d)):
            for cd in range(len(d[0])):
                #if d[rd][cd] < 0.000001 or d[rd][cd] == float('nan'):
                        #d[rd][cd] = distances.euclidean_distances([X[i*segsize+rd]],[Y[len(Y)-len(Y)%segsize+cd]],False)[0][0]
                        #d[rd][cd] = cpu_euclidean_distances(X[i*segsize+rd],Y[len(Y)-len(Y)%segsize+cd])
                hdists[i*segsize+rd][len(Y)-len(Y)%segsize+cd] = d[rd][cd]

    for j in range(len(Y)/segsize):
        d = distances.euclidean_distances(X[len(X)-len(X)%segsize:len(X)],Y[j*segsize:(j+1)*segsize],False)
        for rd in range(len(d)):
            for cd in range(len(d[0])):
                #if d[rd][cd] < 0.000001 or d[rd][cd] == float('nan'):
                        #d[rd][cd] = distances.euclidean_distances([X[len(X)-len(X)%segsize+rd]],[Y[j*segsize+cd]],False)[0][0]
                        #d[rd][cd] = cpu_euclidean_distances(X[len(X)-len(X)%segsize+rd],Y[j*segsize+cd])
                hdists[len(X)-len(X)%segsize+rd][j*segsize+cd] = d[rd][cd]
        
    d = distances.euclidean_distances(X[len(X)-len(X)%segsize:len(X)],Y[len(Y)-len(Y)%segsize:len(Y)],False)
    for rd in range(len(d)):
        for cd in range(len(d[0])):
            #if d[rd][cd] < 0.000001 or d[rd][cd] == float('nan'):
                    #d[rd][cd] = distances.euclidean_distances([X[len(X)-len(X)%segsize+rd]],[Y[len(Y)-len(Y)%segsize+cd]],False)[0][0]
                    #d[rd][cd] = cpu_euclidean_distances(X[len(X)-len(X)%segsize+rd],Y[len(Y)-len(Y)%segsize+cd])
            hdists[len(X)-len(X)%segsize+rd][len(Y)-len(Y)%segsize+cd] = d[rd][cd]  

    return hdists

def cpu_euclidean_distances(v1, v2):
    len1 = len(v1)
    len2 = len(v2)
    if not len1 == len2:
        print('not the same length')
        exit()
    sqSum = 0
    for i in range(0,len1):
        sqSum += math.pow(v1[i] - v2[i],2) 

    return math.sqrt(sqSum)

def cpu_euclidean_distances_wrapper(X, Y):

    solution = np.empty(len(X)*len(Y),dtype=np.float32)
    solution = np.reshape(solution,(len(X),len(Y)))

    for i in range(len(X)):
        for j in range(len(Y)):
            s = cpu_euclidean_distances(X[i],Y[j])
            solution[i][j] = s

    return solution

def getArmOplist(filename, oplist):                    
    f = open(filename, 'r')
    for line in f.readlines():
        temp = line[:-1]
        op = ''
        if temp[-1] == '\r':
            op = temp[:-1]
        else:
            op = temp
        oplist.append(op) #i don't know why the txt file havs /r in each line, but anyway the code is added because of /r/n
    f.close()

def getSysList(filename , syslist):
    f = open(filename, 'r')
    for line in f.readlines():
        temp = line[:-1]
        s = ''
        if temp[-1] == '\r':
            s = temp[:-1]
        else:
            s = temp
        syslist.append(s)
    f.close()

def getBytecodelist(filename, bytecodelist):
    f = open(filename, 'r')
    for line in f.readlines():
        temp = line[:-1]
        if temp[-1] == '\r':
            bytecode = temp[:-1]
        else:
            bytecode = temp
        bytecodelist.append(bytecode)
    f.close()

def getAPIList(filename , apilist):
    f = open(filename, 'r')
    for line in f.readlines():
        temp = line[:-1]
        if temp[-1] == '\r':
            api = temp[:-1]
        else:
            api = temp
        apilist.append(api)
    f.close()

def ManifFeatVect(filename):

    tree = ElementTree() 
    try:
        root = tree.parse(filename)
    except ParseError:
        print('manifest parse error occurs')
        return [set(), set(), set(), set(), set(), set(), list(), list(), list(), list()]

    
    usesPermSet = set()
    for upElement in root.findall("uses-permission"):
        if '{http://schemas.android.com/apk/res/android}name' in upElement.attrib.keys():
            usesPermSet.add(upElement.attrib['{http://schemas.android.com/apk/res/android}name'])
        else:
            usesPermSet.add('name')

    susesPermSet = sorted(usesPermSet)


    usesConfSet = set()
    for ucElement in root.findall("uses-configuration"):
        if '{http://schemas.android.com/apk/res/android}name' in ucElement.attrib.keys():
            usesConfSet.add(ucElement.attrib['{http://schemas.android.com/apk/res/android}name'])
        else:
            usesConfSet.add('name')
    susesConfSet = sorted(usesConfSet)

    usesFeatSet = set()
    for ufElement in root.findall("uses-feature"):
        if '{http://schemas.android.com/apk/res/android}name' in ufElement.attrib.keys():
            usesFeatSet.add(ufElement.attrib['{http://schemas.android.com/apk/res/android}name'])
        else:
            usesFeatSet.add('name')
    susesFeatSet = sorted(usesFeatSet)

    usesLibSet = set()
    for ulElement in root.findall("uses-library"):
        if '{http://schemas.android.com/apk/res/android}name' in ulElement.attrib.keys():
            usesLibSet.add(ulElement.attrib['{http://schemas.android.com/apk/res/android}name'])
        else:
            usesLibSet.add('name')
    susesLibSet = sorted(usesLibSet)

    declarePermSet = set()
    for dpElement in root.findall("permission"):
        dPerm = list()
        if '{http://schemas.android.com/apk/res/android}name' in dpElement.attrib.keys():
            dPerm.append(dpElement.attrib['{http://schemas.android.com/apk/res/android}name'])
        else:
            dPerm.append('name')
        if '{http://schemas.android.com/apk/res/android}permissionGroup' in dpElement.attrib.keys():
            dPerm.append(dpElement.attrib['{http://schemas.android.com/apk/res/android}permissionGroup'])
        else:
            dPerm.append('permissionGroup')
        if '{http://schemas.android.com/apk/res/android}protectionLevel' in dpElement.attrib.keys():
            dPerm.append(dpElement.attrib['{http://schemas.android.com/apk/res/android}protectionLevel'])
        else:
            dPerm.append('protectionLevel')
        if not len(dPerm) == 0:
            declarePermSet.add(str(dPerm))
    sdeclarePermSet = sorted(declarePermSet)

    usesSdkSet = set()
    for usElement in root.findall("uses-sdk"):
        if '{http://schemas.android.com/apk/res/android}name' in usElement.attrib.keys():
            usesSdkSet.add(usElement.attrib['{http://schemas.android.com/apk/res/android}name'])
        else:
            usesSdkSet.add('name')
    susesSdkSet = sorted(usesSdkSet)

    ActivityList = list() ##
    ServiceList = list() ##
    ProviderList = list() ##
    ReceiverList = list() ##

    for appElement in root.findall("application"):
        for actElement in appElement.findall("activity"):
            Activity = list() ##
            if '{http://schemas.android.com/apk/res/android}permission' in actElement.attrib.keys():
                Activity.append(actElement.attrib['{http://schemas.android.com/apk/res/android}permission'])
            else:
                Activity.append('no_permission')
            intentlist = list()
            for intentElement in actElement.findall("intent-filter"):
                intent = list()
                setAct = set()
                setCate = set()
                setData = set()
                for act in intentElement.findall('action'):
                    if '{http://schemas.android.com/apk/res/android}name' in act.attrib.keys():
                        setAct.add(act.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setAct.add('no_name')
                for cate in intentElement.findall('category'):
                    if '{http://schemas.android.com/apk/res/android}name' in cate.attrib.keys():
                        setCate.add(cate.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setCate.add('no_name')
                for data in intentElement.findall('data'):
                    if '{http://schemas.android.com/apk/res/android}name' in data.attrib.keys():
                        setData.add(data.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setData.add('no_name')
                if not len(setAct) == 0:
                    intent.append(sorted(setAct))
                else:
                    intent.append('no_action')
                if not len(setCate) == 0:
                    intent.append(sorted(setCate))
                else:
                    intent.append('no_category')
                if not len(setData) == 0:
                    intent.append(sorted(setData))
                else:
                    intent.append('no_data')
                if not len(intent) == 0:
                    intentlist.append(intent)
                else:
                    intentlist.append('no_intent')
            if not len(intentlist) == 0:
                Activity.append(intentlist) ##
            else:
                Activity.append('no_intent')
            if not len(Activity) == 0:
                ActivityList.append(Activity) ##

        for servElement in appElement.findall("service"):
            Service = list() ##
            if '{http://schemas.android.com/apk/res/android}permission' in servElement.attrib.keys():
                Service.append(servElement.attrib['{http://schemas.android.com/apk/res/android}permission'])
            else:
                Service.append('no_permission')
            intentlist = list()
            for intentElement in servElement.findall("intent-filter"):
                intent = list()
                setAct = set()
                setCate = set()
                setData = set()
                for act in intentElement.findall('action'):
                    if '{http://schemas.android.com/apk/res/android}name' in act.attrib.keys():
                        setAct.add(act.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setAct.add('no_name')
                for cate in intentElement.findall('category'):
                    if '{http://schemas.android.com/apk/res/android}name' in cate.attrib.keys():
                        setCate.add(cate.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setCate.add('no_name')
                for data in intentElement.findall('data'):
                    if '{http://schemas.android.com/apk/res/android}name' in data.attrib.keys():
                        setData.add(data.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setData.add('no_name')
                if not len(setAct) == 0:
                    intent.append(sorted(setAct))
                else:
                    intent.append('no_action')
                if not len(setCate) == 0:
                    intent.append(sorted(setCate))
                else:
                    intent.append('no_category')
                if not len(setData) == 0:
                    intent.append(sorted(setData))
                else:
                    intent.append('no_data')
                if not len(intent) == 0:
                    intentlist.append(intent)
                else:
                    intentlist.append('no_intent')
            if not len(intentlist) == 0:
                Service.append(intentlist) ##
            else:
                Service.append('no_intent')
            if not len(Service) == 0:
                ServiceList.append(Service) #

        for provElement in appElement.findall("provider"):
            Provider = list() ##
            if '{http://schemas.android.com/apk/res/android}permission' in provElement.attrib.keys():
                Provider.append(provElement.attrib['{http://schemas.android.com/apk/res/android}permission'])
            else:
                Provider.append('no_permission')
            GUPlist = list()
            for GUPElement in provElement.findall('grant-uri-permission'):
                GUP = list();
                if '{http://schemas.android.com/apk/res/android}path' in GUPElement.attrib.keys():
                    GUP.append(GUPElement.attrib['{http://schemas.android.com/apk/res/android}path']) ##
                else:
                    GUP.append('no_name')
                if '{http://schemas.android.com/apk/res/android}pathPattern' in GUPElement.attrib.keys():
                    GUP.append(GUPElement.attrib['{http://schemas.android.com/apk/res/android}pathPattern']) ##
                else:
                    GUP.append('no_name')
                if '{http://schemas.android.com/apk/res/android}pathPrefix' in GUPElement.attrib.keys():
                    GUP.append(GUPElement.attrib['{http://schemas.android.com/apk/res/android}pathPrefix']) ##
                else:
                    GUP.append('no_name')
                if not len(GUP) == 0:
                    GUPlist.append(GUP)
            if not len(GUPlist)==0:
                Provider.append(GUPlist)
            else:
                Provider.append('no_grant-uri-permission')
            intentlist = list()
            for intentElement in provElement.findall("intent-filter"):
                intent = list()
                setAct = set()
                setCate = set()
                setData = set()
                for act in intentElement.findall('action'):
                    if '{http://schemas.android.com/apk/res/android}name' in act.attrib.keys():
                        setAct.add(act.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setAct.add('no_name')
                for cate in intentElement.findall('category'):
                    if '{http://schemas.android.com/apk/res/android}name' in cate.attrib.keys():
                        setCate.add(cate.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setCate.add('no_name')
                for data in intentElement.findall('data'):
                    if '{http://schemas.android.com/apk/res/android}name' in data.attrib.keys():
                        setData.add(data.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setData.add('no_name')
                if not len(setAct) == 0:
                    intent.append(sorted(setAct))
                else:
                    intent.append('no_action')
                if not len(setCate) == 0:
                    intent.append(sorted(setCate))
                else:
                    intent.append('no_category')
                if not len(setData) == 0:
                    intent.append(sorted(setData))
                else:
                    intent.append('no_data')
                if not len(intent) == 0:
                    intentlist.append(intent)
                else:
                    intentlist.append('no_intent')
            if not len(intentlist) == 0:
                Provider.append(intentlist) ##
            else:
                Provider.append('no_intent')
            if not len(Provider) == 0:
                ProviderList.append(Provider) ##

        for recvElement in appElement.findall("receiver"):
            Receiver = list() ##
            if '{http://schemas.android.com/apk/res/android}permission' in recvElement.attrib.keys():
                Receiver.append(recvElement.attrib['{http://schemas.android.com/apk/res/android}permission'])
            else:
                Receiver.append('no_permission')
            intentlist = list()
            for intentElement in recvElement.findall("intent-filter"):
                intent = list()
                setAct = set()
                setCate = set()
                setData = set()
                for act in intentElement.findall('action'):
                    if '{http://schemas.android.com/apk/res/android}name' in act.attrib.keys():
                        setAct.add(act.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setAct.add('no_name')
                for cate in intentElement.findall('category'):
                    if '{http://schemas.android.com/apk/res/android}name' in cate.attrib.keys():
                        setCate.add(cate.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setCate.add('no_name')
                for data in intentElement.findall('data'):
                    if '{http://schemas.android.com/apk/res/android}name' in data.attrib.keys():
                        setData.add(data.attrib['{http://schemas.android.com/apk/res/android}name'])
                    else:
                        setData.add('no_name')
                if not len(setAct) == 0:
                    intent.append(sorted(setAct))
                else:
                    intent.append('no_action')
                if not len(setCate) == 0:
                    intent.append(sorted(setCate))
                else:
                    intent.append('no_category')
                if not len(setData) == 0:
                    intent.append(sorted(setData))
                else:
                    intent.append('no_data')
                if not len(intent) == 0:
                    intentlist.append(intent)
                else:
                    intentlist.append('no_intent')
            if not len(intentlist) == 0:
                Receiver.append(intentlist) ##
            else:
                Receiver.append('no_intent')
            if not len(Receiver) == 0:
                ReceiverList.append(Receiver) ##

    return [susesPermSet, susesConfSet, susesFeatSet, susesLibSet, sdeclarePermSet, susesSdkSet, ActivityList, ServiceList, ProviderList, ReceiverList]

def searchToEXconstStringsNmethods(dirname, constStrings, methodsOP, methodsAPI, dalist, bytelist): #^^^^
    flist = os.listdir(dirname)
    for f in flist:
        next = os.path.join(dirname, f)
        if os.path.isdir(next):
            searchToEXconstStringsNmethods(next,constStrings,methodsOP,methodsAPI,dalist,bytelist)
        else:
            (strset, msetOP, msetAPI)= extractconstStringNMethods(next,dalist,bytelist)
            methodsOP.update(msetOP)
            methodsAPI.update(msetAPI)
            constStrings.update(strset)

def extractconstStringNMethods(filename, dalist, bytelist):
    ext = os.path.splitext(filename)[-1]
    retStringSet = set()
    MethodOPSet = set()
    MethodAPISet = set()
    ongoing = False

    if ext == '.smali':
        if not os.path.exists(os.path.abspath(filename)):
            return (retStringSet, MethodOPSet,MethodAPISet)
        f = open(os.path.abspath(filename),'r')
        try:
            lines = f.readlines()
        except UnicodeDecodeError:
            return (retStringSet, MethodOPSet,MethodAPISet)

        for line in lines:
            if line.count('.method')==1:
                MfeatsOP = list()
                MfeatsAPI = list()
                for m in range(217):
                    MfeatsOP.append(0)
                for m in range(len(dalist)):
                    MfeatsAPI.append(0)
                ongoing=True
            elif line.count('.end method')==1:
                MethodOPSet.add(tuple(MfeatsOP))
                MethodAPISet.add(tuple(MfeatsAPI))
                ongoing=False
            elif ongoing==True:
                bytecode = ""
                if not len(line.split()) == 0:
                    bytecode = line.split()[0]
                if bytecode in bytelist:
                    if bytecode == 'const-string/jumbo':
                        if len(line.split('\"')) < 2:
                            continue
                        tmpstr = str(line.split('\"')[1])
                        hashval = int(hashlib.sha512(tmpstr).hexdigest(),16)%10000
                        retStringSet.add(hashval)
                    elif bytecode == 'const-string':
                        if len(line.split('\"')) < 2:
                            continue
                        tmpstr = str(line.split('\"')[1])
                        hashval = int(hashlib.sha512(tmpstr).hexdigest(),16)%10000
                        retStringSet.add(hashval)
                    elif bytecode == 'invoke-virtual':
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    elif bytecode == 'invoke-super':
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    elif bytecode == 'invoke-direct':
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    elif bytecode == 'invoke-static':
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    elif bytecode == 'invoke-interface':
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    elif bytecode == 'invoke-virtual/range':
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    elif bytecode == 'invoke-super/range':
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    elif bytecode == 'invoke-direct/range' == 1:
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    elif bytecode == 'invoke-static/range':
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    elif bytecode == 'invoke-interface/range':
                        for a in dalist:
                            try:
                                if line.split('->')[1].count(a) == 1:
                                    MfeatsAPI[dalist.index(a)] +=1
                            except IndexError:
                                pass
                    MfeatsOP[bytelist.index(bytecode)] += 1                
        f.close()
    return (retStringSet, MethodOPSet,MethodAPISet)

def searchToEXfunc(dirname, funcsOP, funcsSYS, dslist, oplist): 
    flist = os.listdir(dirname)

    for f in flist:
        next = os.path.join(dirname, f)
        if os.path.isdir(next):
            searchToEXfunc(next, funcsOP, funcsSYS, dslist, oplist)
        else:
            (fsetOP, fsetSYS) =  extractFunc(next,dslist,oplist)
            funcsOP.update(fsetOP)
            funcsSYS.update(fsetSYS)

def extractFunc(filename,dslist,oplist): 
    ext = os.path.splitext(filename)[-1]
    FuncOPSet = set()
    FuncSYSSet = set()
    numedge = 0
    numnode = 0
    #if os.path.basename(filename)[0:3] != "sub":
    #    return (FuncOPSet, FuncSYSSet)
    if ext == '.gdl':
        ongoing = False
        if filename.count('callgraph.gdl')==1:
            return (FuncOPSet, FuncSYSSet)
        f = codecs.open(os.path.abspath(filename),errors='ignore')
        FfeatsOP = list()
        FfeatsSYS = list()
        for index in range(1321):
            FfeatsOP.append(0)
        for index in range(len(dslist)):
            FfeatsSYS.append(0)
        try:
            lines = f.readlines()
        except UnicodeDecodeError:
            return (FuncOPSet, FuncSYSSet)
        ii = 0
        for line in lines:
            s = line
            op = line.split()[0].lower()
            if op in oplist:
                if op == 'blx':
                    trane = s.replace(';',' ').replace('"',' ').replace('}',' ').replace('(',' ').replace(')',' ')
                    for e in trane.split():
                        tmpSys = e.lower()
                        if tmpSys in dslist:
                            FfeatsSYS[dslist.index(tmpSys)] += 1
                        elif '__imp_'+e.lower() == e:
                            FfeatsSYS[dslist.index(tmpSys)] += 1
                elif op == 'bl':
                    trane = s.replace(';',' ').replace('"',' ').replace('}',' ').replace('(',' ').replace(')',' ')
                    for e in trane.split():
                        tmpSys = e.lower()
                        if tmpSys in dslist:
                            FfeatsSYS[dslist.index(tmpSys)] += 1
                        elif '__imp_'+e.lower() == e:
                            FfeatsSYS[dslist.index(tmpSys)] += 1
                else:
                    FfeatsOP[oplist.index(op)] += 1
        f.close()
        FuncOPSet.add(tuple(FfeatsOP))
        FuncSYSSet.add(tuple(FfeatsSYS))
    return (FuncOPSet, FuncSYSSet)

def featVectorGen(logname, referlist, tupset, tucset, tufset, tulset, tdpset, tusset, tactset, tservset, tprovset, trecvset, tstrset, tmethodOPset, tmethodAPIset, tfuncOPset, tfuncSYSset, dslist, dalist, bytelist, oplist, mminlist, mmaxlist, fminlist, fmaxlist, apklist): 
    
    featVectlist = list()
    ssindex = len(tupset) + len(tucset) + len(tufset) + len(tulset) + len(tdpset) + len(tusset) + len(tactset) + len(tservset) + len(tprovset) + len(trecvset)
    msOPindex = ssindex + len(tstrset)
    msAPIindex = msOPindex + len(tmethodOPset)
    fsOPindex = msAPIindex + len(tmethodAPIset)
    fsSYSindex = fsOPindex + len(tfuncOPset)
    hsindex = fsSYSindex + len(tfuncSYSset)

    flog = open(logname, 'a')

    mOPNoXRows = msAPIindex-msOPindex
    mOPNoXColms = len(referlist[msOPindex])
    mOPX = np.empty(mOPNoXRows*mOPNoXColms)
    for rindex in range(msOPindex, msAPIindex):
        r = referlist[rindex]
        for i in range(len(r)):
            mOPX[i+(rindex-msOPindex)*mOPNoXColms] = float(r[i])

    mOPX = np.reshape(mOPX,(mOPNoXRows,mOPNoXColms))
    #############################################################

    mAPINoXRows = fsOPindex-msAPIindex
    mAPINoXColms = len(referlist[msAPIindex])
    mAPIX = np.empty(mAPINoXRows*mAPINoXColms)
    for rindex in range(msAPIindex, fsOPindex):
        r = referlist[rindex]
        for i in range(len(r)):
            mAPIX[i+(rindex-msAPIindex)*mAPINoXColms] = float(r[i])

    mAPIX = np.reshape(mAPIX,(mAPINoXRows,mAPINoXColms))
    #############################################################

    fOPNoXRows = fsSYSindex-fsOPindex
    fOPNoXColms = len(referlist[fsOPindex])
    fOPX = np.empty(fOPNoXRows*fOPNoXColms)
    for rindex in range(fsOPindex, fsSYSindex):
        r = referlist[rindex]
        for i in range(len(r)):
            fOPX[i+(rindex-fsOPindex)*fOPNoXColms] = float(r[i])

    fOPX = np.reshape(fOPX,(fOPNoXRows,fOPNoXColms))
    #############################################################

    fSYSNoXRows = hsindex-fsSYSindex
    fSYSNoXColms = len(referlist[fsSYSindex])
    fSYSX = np.empty(fSYSNoXRows*fSYSNoXColms)
    for rindex in range(fsSYSindex, hsindex):
        r = referlist[rindex]
        for i in range(len(r)):
            fSYSX[i+(rindex-fsSYSindex)*fSYSNoXColms] = float(r[i])

    fSYSX = np.reshape(fSYSX,(fSYSNoXRows,fSYSNoXColms))
    #############################################################

    for apk in apklist:
        print(apk)
        #initial vector generation (dict structure)
        initvector = dict()    
        for refer in referlist:
            initvector[refer] = 0
        for index_m in range(msOPindex, hsindex):
            r = referlist[index_m]
            initvector[r] = 9999
        #for index_f in range(fsindex, hsindex):
        #    r = referlist[index_f]
        #    initvector[r] = 9999

        initvector['classlabel'] = 'N'

        ########################## manifest ##########################
        manifest = taskParam_rawdatadirname+apk+'/'+apk+'_mani.xml'
        
        if os.path.exists(manifest):
            #print(apk+' collectManifest')
            resultFeats = ManifFeatVect(manifest)
            #print(apk+' Log Mani Exitence')
            for item in resultFeats[0]:
                if item in referlist:
                    initvector[item] = 1
            for item in resultFeats[1]:
                if item in referlist:
                    initvector[item] = 1
            for item in resultFeats[2]:
                if item in referlist:
                    initvector[item] = 1
            for item in resultFeats[3]:
                if item in referlist:
                    initvector[item] = 1
            for item in resultFeats[4]:
                if item in referlist:
                    initvector[item] = 1
            for item in resultFeats[5]:
                if item in referlist:
                    initvector[item] = 1
            for i in resultFeats[6]:
                if str(i) in referlist:
                    initvector[str(i)]=1
            for i in resultFeats[7]:
                if str(i) in referlist:
                    initvector[str(i)]=1
            for i in resultFeats[8]:
                if str(i) in referlist:
                    initvector[str(i)]=1
            for i in resultFeats[9]:
                if str(i) in referlist:
                    initvector[str(i)]= 1
        ######################  method & string ######################
        constStrings = set()
        MethodsOP = set()
        MethodsAPI = set()
        #get smali dirs
        #print(apk+' collectStrMethods')
        if os.path.exists(taskParam_rawdatadirname+apk+'/'+apk+'_smali'):
            smalidirs = os.listdir(taskParam_rawdatadirname+apk+'/'+apk+'_smali')
            for d in smalidirs:
                smalidir = taskParam_rawdatadirname+apk+'/'+apk+'_smali'+'/'+d
                if not os.path.isdir(smalidir) or smalidir=='.' or smalidir == '/':
                    continue
                tmpconstStrings = set()
                tmpMethodsOP = set()
                tmpMethodsAPI = set()
                #get string method sets
                searchToEXconstStringsNmethods(smalidir,tmpconstStrings,tmpMethodsOP, tmpMethodsAPI, dalist, bytelist)
                constStrings.update(tmpconstStrings)
                MethodsOP.update(tmpMethodsOP)
                MethodsAPI.update(tmpMethodsAPI)


        for i in constStrings:
            if (str(i)) in referlist:
                initvector[str(i)]=1

        mOPNoYRows = len(MethodsOP)
        mAPINoYRows = len(MethodsAPI)
        mOPNoYColms = mOPNoXColms
        mAPINoYColms = mAPINoXColms

        mOPY = np.empty(mOPNoYRows*mOPNoYColms)
        mAPIY = np.empty(mAPINoYRows*mAPINoYColms)

        itemindex = 0
        for item in MethodsOP:
            for i in range(len(item)):
                mOPY[i+itemindex*mOPNoYColms] = float(item[i])
            itemindex+=1
        itemindex = 0
        for item in MethodsAPI:
            for i in range(len(item)):
                mAPIY[i+itemindex*mAPINoYColms] = float(item[i])
            itemindex+=1

        mOPY = np.reshape(mOPY,(mOPNoYRows,mOPNoYColms))
        mAPIY = np.reshape(mAPIY,(mAPINoYRows,mAPINoYColms))

        if not mOPNoYRows == 0:

            distsOP = gpu_euclidean_distances_wrapper_naive(mOPX,mOPY)
            distsAPI = gpu_euclidean_distances_wrapper_naive(mAPIX,mAPIY)

            for i in range(msOPindex, msAPIindex):
                if float(np.nanmin(distsOP[i-msOPindex])) == -1:
                    sim = 1
                else:
                    sim = float(1/(1+float(np.nanmin(distsOP[i-msOPindex]))))
                if sim == 1:
                    for j in range(len(distsOP[i-msOPindex])):
                        if distsOP[i-msOPindex][j] < 0.00001 or distsOP[i-msOPindex][j] == float('nan'):
                            if not np.array_equal(mOPX[i-msOPindex],mOPY[j]):
                                distsOP[i-msOPindex][j] = cpu_euclidean_distances(mOPX[i-msOPindex],mOPY[j])
                    sim = float(1/(1+float(np.nanmin(distsOP[i-msOPindex]))))
                initvector[referlist[i]] = sim

            for i in range(msAPIindex, fsOPindex):
                if float(np.nanmin(distsAPI[i-msAPIindex])) == -1:
                    sim = 1
                else:
                    sim = float(1/(1+float(np.nanmin(distsAPI[i-msAPIindex]))))
                if sim == 1:
                    for j in range(len(distsAPI[i-msAPIindex])):
                        if distsAPI[i-msAPIindex][j] < 0.00001 or distsAPI[i-msAPIindex][j] == float('nan'):
                            if not np.array_equal(mAPIX[i-msAPIindex],mAPIY[j]):
                                distsAPI[i-msAPIindex][j] = cpu_euclidean_distances(mAPIX[i-msAPIindex],mAPIY[j])
                    sim = float(1/(1+float(np.nanmin(distsAPI[i-msAPIindex]))))
                initvector[referlist[i]] = sim

        else:
            print('no methods really?')
        ########################### func   ###########################
        #get so file list
        #print(apk+' collectFunc')
        solist = glob.glob(taskParam_rawdatadirname+apk+'/*.so')
        FuncOPSet = set()
        FuncSYSSet = set()
        for sofile  in solist:
            if os.path.exists(sofile[:-3]+'/GDL') or len(glob.glob(sofile[:-3]+'/*.gdl'))>0:
                #get func set
                FuncsOP = set()
                FuncsSYS = set()

                searchToEXfunc(sofile[:-3], FuncsOP, FuncsSYS, dslist, oplist)
                FuncOPSet.update(FuncsOP)
                FuncSYSSet.update(FuncsSYS)

        fOPNoYRows = len(FuncOPSet)
        fSYSNoYRows = len(FuncSYSSet)
        fOPNoYColms = fOPNoXColms
        fSYSNoYColms = fSYSNoXColms

        fOPY = np.empty(fOPNoYRows*fOPNoYColms)
        fSYSY = np.empty(fSYSNoYRows*fSYSNoYColms)

        itemindex = 0
        for item in FuncOPSet:
            for i in range(len(item)):
                fOPY[i+itemindex*fOPNoYColms] = float(item[i])
            itemindex+=1

        itemindex = 0
        for item in FuncSYSSet:
            for i in range(len(item)):
                fSYSY[i+itemindex*fSYSNoYColms] = float(item[i])
            itemindex+=1

        fOPY = np.reshape(fOPY,(fOPNoYRows,fOPNoYColms))
        fSYSY = np.reshape(fSYSY,(fSYSNoYRows,fSYSNoYColms))

        if not fOPNoYRows == 0:
            distsOP = gpu_euclidean_distances_wrapper_naive(fOPX,fOPY)
            distsSYS = gpu_euclidean_distances_wrapper_naive(fSYSX,fSYSY)

            for i in range(fsOPindex, fsSYSindex):
                if float(np.nanmin(distsOP[i-fsOPindex])) == -1:
                    sim = 1
                else:
                    sim = float(1/(1+float(np.nanmin(distsOP[i-fsOPindex]))))
                if sim == 1:
                    for j in range(len(distsOP[i-fsOPindex])):
                        if distsOP[i-fsOPindex][j] < 0.00001 or distsOP[i-fsOPindex][j] == float('nan'):
                            if not np.array_equal(fOPX[i-fsOPindex],fOPY[j]):
                                distsOP[i-fsOPindex][j] = cpu_euclidean_distances(fOPX[i-fsOPindex],fOPY[j])
                    sim = float(1/(1+float(np.nanmin(distsOP[i-fsOPindex]))))
                initvector[referlist[i]] = sim

            for i in range(fsSYSindex, hsindex):
                if float(np.nanmin(distsSYS[i-fsSYSindex])) == -1:
                    sim = 1
                else:
                    sim = float(1/(1+float(np.nanmin(distsSYS[i-fsSYSindex]))))
                if sim == 1:
                    for j in range(len(distsSYS[i-fsSYSindex])):
                        if distsSYS[i-fsSYSindex][j] < 0.00001 or distsSYS[i-fsSYSindex][j] == float('nan'):
                            if not np.array_equal(fSYSX[i-fsSYSindex],fSYSY[j]):
                                distsSYS[i-fsSYSindex][j] = cpu_euclidean_distances(distsSYS[i-fsSYSindex],fSYSY[j])
                    sim = float(1/(1+float(np.nanmin(distsSYS[i-fsSYSindex]))))
                initvector[referlist[i]] = sim

        else:
            print('no funcs really?')
        
        if not apk[0] == 'g':
            initvector['classlabel'] = 'M'
        else:
            initvector['classlabel'] = 'B'
        initvector['filename'] = apk
        #add the vector of this apk to return feature vector list
        singleVector = list()
        for refer in referlist:
        	singleVector.append(str(initvector[refer]))
        for i in range(len(singleVector)):
            if singleVector[i] == '9999':
                singleVector[i] = '0'
            flog.write(str(singleVector[i]))
            flog.write(' ')
        flog.write('\n')
    flog.close()

def arffGenAlltype():
    
    LogNames = glob.glob(taskParam_Arffdirname+'Feat*')

    # get total feat sets
    tUPset = set()
    tUCset = set()
    tUFset = set()
    tULset = set()
    tDPset = set()
    tUSset = set()
    tACTset = set()
    tSERVset = set()
    tPROVset = set()
    tRECVset = set()
    tConstStringSet = set()
    tMethodOPSet = set()
    tMethodAPISet = set()
    tFuncOPSet = set()
    tFuncSYSSet = set()
    
    getTotalFeatSets(tUPset, tUCset, tUFset, tULset, tDPset, tUSset, tACTset, tSERVset, tPROVset, tRECVset, tConstStringSet, tMethodOPSet, tMethodAPISet, tFuncOPSet, tFuncSYSSet)

    manifestSize = len(tUPset)+len(tUCset)+len(tUFset)+len(tULset)+len(tDPset)+len(tUSset)+len(tACTset)+len(tSERVset)+len(tPROVset)+len(tRECVset)
    stringSize = len(tConstStringSet)
    methodOPSize = len(tMethodOPSet)
    methodAPISize = len(tMethodAPISet)
    functionOPSize = len(tFuncOPSet)
    functionSYSSize = len(tFuncSYSSet)

    print(manifestSize)
    print(stringSize)
    print(methodOPSize)
    print(methodAPISize)
    print(functionOPSize)
    print(functionSYSSize)
    print(manifestSize+stringSize+methodOPSize+methodAPISize+functionOPSize+functionSYSSize)

    #arffgeneration([1,1,1,1,1,0,0],[manifestSize,stringSize,methodOPSize,methodAPISize,functionOPSize,functionSYSSize,0], LogNames, taskParam_Arffdirname, manifestSize+stringSize+methodOPSize+methodAPISize+functionOPSize+functionSYSSize+2)

    for i in range(2):
        for ii in range(2):
            for iii in range(2):
                for iiii in range(2):
                    for iiiii in range(2):
                        for iiiiii in range(2):
                            arffgeneration([i,ii,iii,iiii,iiiii,iiiiii,0],[manifestSize,stringSize,methodOPSize,methodAPISize,functionOPSize,functionSYSSize,0], LogNames, taskParam_Arffdirname, manifestSize+stringSize+methodOPSize+methodAPISize+functionOPSize+functionSYSSize+2)

def arffgeneration(CombList, List_NoOfFeatures, logs, dirpath, fvlen):
    # List_NoOfFeatures has the number of the each feature type
    # manifest -> index = 0
    # string -> index = 1
    # methodOP -> index =2
    # methodAPI -> index =3
    # functionOP -> index = 4
    # functionSYS -> index = 5
    # image -> index = 6

    print(CombList)

    filename = dirpath
    if not CombList[0] == 0:
        filename += "manifest_"
    if not CombList[1] == 0:
        filename += "string_"
    if not CombList[2] == 0:
        filename += "methodOP_"
    if not CombList[3] == 0:
        filename += "methodAPI_"
    if not CombList[4] == 0:
        filename += "functionOP_"
    if not CombList[5] == 0:
        filename += "functionSYS_"
    if not CombList[6] == 0:
        filename += "image_"
    filename += ".arff"

    print(filename)

    f = open(filename,'w')
    f.write("@relation OhGodPleaseGiveMeAGoodResult\n\n")
    

    if not CombList[0] == 0:
        for i in range(List_NoOfFeatures[0]):
            f.write("@attribute ")
            f.write("manifest_")
            f.write(str(i))
            f.write(" numeric\n")
    if not CombList[1] == 0:
        for i in range(List_NoOfFeatures[1]):
            f.write("@attribute ")
            f.write("string_")
            f.write(str(i))
            f.write(" numeric\n")
    if not CombList[2] == 0:
        for i in range(List_NoOfFeatures[2]):
            f.write("@attribute ")
            f.write("methodOP_")
            f.write(str(i))
            f.write(" numeric\n")
    if not CombList[3] == 0:
        for i in range(List_NoOfFeatures[3]):
            f.write("@attribute ")
            f.write("methodAPI_")
            f.write(str(i))
            f.write(" numeric\n")
    if not CombList[4] == 0:
        for i in range(List_NoOfFeatures[4]):
            f.write("@attribute ")
            f.write("functionOP_")
            f.write(str(i))
            f.write(" numeric\n")
    if not CombList[5] == 0:
        for i in range(List_NoOfFeatures[5]):
            f.write("@attribute ")
            f.write("functionSYS_")
            f.write(str(i))
            f.write(" numeric\n")
    if not CombList[6] == 0:
        for i in range(List_NoOfFeatures[6]):
            f.write("@attribute ")
            f.write("image_")
            f.write(str(i))
            f.write(" numeric\n")
    
    f.write("@attribute ")
    f.write("class")
    f.write("{M, B}\n")

    f.write("@attribute ")
    f.write("apk")
    f.write(" string\n\n")

    f.write("@data\n")

    for log in logs:
        flog = open(log,'r')
        while True:
            line = flog.readline()
            if line == "":
                break

            fv = list()
            fv = line.split()

            if not len(fv) == fvlen:
                continue

            awkwardFlag =False
            for i in range(len(fv)-2):
                if 0 < float(fv[i]) and float(fv[i]) < 0.000001:
                    awkwardFlag = True
                    break
                elif float(fv[i]) == float('nan'):
                    awkwardFlag = True
                    break
            if awkwardFlag == True:
                continue

            if not CombList[0] == 0:
                for i in range(0,List_NoOfFeatures[0]):
                    f.write(str(fv[i]))
                    f.write(", ")
            if not CombList[1] == 0:        
                for i in range(0,List_NoOfFeatures[1]):
                    f.write(str(fv[i+List_NoOfFeatures[0]]))
                    f.write(", ")
            if not CombList[2] == 0: 
                for i in range(0,List_NoOfFeatures[2]):
                    f.write(str(fv[i+List_NoOfFeatures[0]+List_NoOfFeatures[1]]))
                    f.write(", ")
            if not CombList[3] == 0:
                for i in range(0,List_NoOfFeatures[3]):
                    f.write(str(fv[i+List_NoOfFeatures[0]+List_NoOfFeatures[1]+List_NoOfFeatures[2]]))
                    f.write(", ")
            if not CombList[4] == 0:
                for i in range(0,List_NoOfFeatures[4]):
                    f.write(str(fv[i+List_NoOfFeatures[0]+List_NoOfFeatures[1]+List_NoOfFeatures[2]+List_NoOfFeatures[3]]))
                    f.write(", ")
            if not CombList[5] == 0:
                for i in range(0,List_NoOfFeatures[5]):
                    f.write(str(fv[i+List_NoOfFeatures[0]+List_NoOfFeatures[1]+List_NoOfFeatures[2]+List_NoOfFeatures[3]+List_NoOfFeatures[4]]))
                    f.write(", ")
            if not CombList[6] == 0:
                for i in range(0,List_NoOfFeatures[6]):
                    f.write(str(fv[i+List_NoOfFeatures[0]+List_NoOfFeatures[1]+List_NoOfFeatures[2]+List_NoOfFeatures[3]+List_NoOfFeatures[4]+List_NoOfFeatures[5]]))
                    f.write(", ")

            f.write(str(fv[-2]))
            f.write(", ")
            f.write(str(fv[-1]))
            f.write("\n")
        flog.close()        
    f.close()

def GoGetFeatVects(apklist_txt, log_txt):
    ############################### main ###############################
    # get total feat sets
    tUPset = set()
    tUCset = set()
    tUFset = set()
    tULset = set()
    tDPset = set()
    tUSset = set()
    tACTset = set()
    tSERVset = set()
    tPROVset = set()
    tRECVset = set()
    tConstStringSet = set()
    tMethodOPSet = set() 
    tMethodAPISet = set()
    tFuncOPSet = set() 
    tFuncSYSSet = set()

    getTotalFeatSets(tUPset, tUCset, tUFset, tULset, tDPset, tUSset, tACTset, tSERVset, tPROVset, tRECVset, tConstStringSet, tMethodOPSet, tMethodAPISet, tFuncOPSet, tFuncSYSSet) 

    #make key list(referlist) for referring each feature in dictionary
    referlist = list()
    for item in tUPset:
        referlist.append(item)
    for item in tUCset:
        referlist.append(item)
    for item in tUFset:
        referlist.append(item)
    for item in tULset:
        referlist.append(item)
    for item in tDPset:
        referlist.append(item)
    for item in tUSset:
        referlist.append(item)
    for item in tACTset:
        referlist.append(item)
    for item in tSERVset:
        referlist.append(item)
    for item in tPROVset:
        referlist.append(item)
    for item in tRECVset:
        referlist.append(item)
    for item in tConstStringSet:
        referlist.append(str(item))
    
    msOPindex = len(referlist)
    for item in tMethodOPSet: 
        referlist.append((item))
    msAPIindex = len(referlist)
    for item in tMethodAPISet: 
        referlist.append((item))
    fsOPindex = len(referlist)
    for item in tFuncOPSet:
        referlist.append((item))
    fsSYSindex = len(referlist)
    for item in tFuncSYSSet:
        referlist.append((item))

    referlist.append('classlabel')
    referlist.append('filename')

    #get system call list api list bytecode list opcode list apk list 
    dslist = list()
    getSysList(taskParam_syslistfilename, dslist)
    dalist = list()
    getAPIList(taskParam_apilistfilename, dalist)
    bytelist = list()
    getBytecodelist(taskParam_bytecodelistfilename,bytelist)
    oplist = list()
    getArmOplist(taskParam_oplistfilename,oplist)

    fapklist = open(apklist_txt,'r') # get apk list
    lines = fapklist.readlines()
    fapklist.close()
    noofapks = len(lines)
    apklist = list()
    for line in lines:
        apklist.append(line[:-1])

    tempLogName = taskParam_Arffdirname+log_txt

    mminlist = list()
    mmaxlist = list()
    fminlist = list()
    fmaxlist = list()

    #fminmaxmethod = open(taskParam_methodminmax, 'r')
    #lines = fminmaxmethod.readlines()
    #for mmin in lines[1].split():
    #    mminlist.append(float(mmin))
    #for mmax in lines[2].split():
    #    mmaxlist.append(float(mmax))
    #fminmaxmethod.close()

    #fminmaxfunc = open(taskParam_funcminmax, 'r')
    #lines = fminmaxfunc.readlines()
    #for fmin in lines[1].split():
    #    fminlist.append(float(fmin))
    #for fmax in lines[2].split():
    #    fmaxlist.append(float(fmax))
    #fminmaxfunc.close()

    featVectorGen(tempLogName, referlist, tUPset, tUCset, tUFset, tULset, tDPset, tUSset, tACTset, tSERVset, tPROVset, tRECVset, tConstStringSet, tMethodOPSet, tMethodAPISet, tFuncOPSet, tFuncSYSSet, dslist, dalist, bytelist, oplist, mminlist, mmaxlist, fminlist, fmaxlist, apklist)

#check the windows disk is mounted...


#GoGetFeatVects('apklist0.txt','Feat0.txt')
#GoGetFeatVects('apklist1.txt','Feat1.txt')
#GoGetFeatVects('apklist2.txt','Feat2.txt')
#GoGetFeatVects('apklist3.txt','Feat3.txt')
#GoGetFeatVects('apklist4.txt','Feat4.txt')
#GoGetFeatVects('apklist5.txt','Feat5.txt')
#GoGetFeatVects('apklist6.txt','Feat6.txt')
#GoGetFeatVects('apklist7.txt','Feat7.txt')
#GoGetFeatVects('apklist8.txt','Feat8.txt')
#GoGetFeatVects('apklist9.txt','Feat9.txt')

arffGenAlltype()


#getRawsofTopKs(k=1000)

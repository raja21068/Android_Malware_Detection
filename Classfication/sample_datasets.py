import os
import numpy as np
from sklearn.model_selection import train_test_split


def load(path, AllTorOneF):

    if not os.path.exists(path):
        print(path+'not valid dataset file')
        return -1

    #f = open(path, 'r')
    manifcount=0
    methodOPfcount=0
    methodAPIfcount=0
    strfcount=0
    funcOPfcount=0
    funcSYSfcount=0
    Imgfcount=0
    numSamples=0
    Mapknames = list()
    Bapknames = list()
    numMdata=0
    numBdata=0
    flag = False
    k=0
    mcount=0
    bcount=0
    
    SetOfTotalMapks = list()
    SetOfTotalBapks = list()

    manifestFlag = False
    stringFlag = False
    methodOPFlag = False
    methodAPIFlag = False
    functionOPFlag = False
    functionSYSFlag = False


    noOffeattyps = 0

    if not path.find('manifest') == -1:
        manifestFlag = True
        noOffeattyps+=1
    if not path.find('string') == -1:
        stringFlag = True
        noOffeattyps+=1
    if not path.find('methodOP') == -1:
        methodOPFlag = True
        noOffeattyps+=1
    if not path.find('methodAPI') == -1:
        methodAPIFlag = True
        noOffeattyps+=1
    if not path.find('functionOP') == -1:
        functionOPFlag = True
        noOffeattyps+=1
    if not path.find('functionSYS') == -1:
        functionSYSFlag = True
        noOffeattyps+=1

    fposapks = open(os.path.dirname(path)+"/possibleApks/"+os.path.basename(path)+"_possibleApks.txt")
    lines = fposapks.readlines()

    for i in range(len(lines)-1):
        tmpcount = noOffeattyps
        s = lines[i].split()
        if manifestFlag == True:
            if s[1] == 'False': #exists
                tmpcount-=1
        if stringFlag == True:
            if s[2] == 'False':
                tmpcount-=1
        if methodOPFlag == True:
            if s[3] == 'False':
                tmpcount-=1
        if methodAPIFlag == True:
            if s[4] == 'False':
                tmpcount-=1
        if functionOPFlag == True:
            if s[5] == 'False':
                tmpcount-=1
        if functionSYSFlag == True:
            if s[6] == 'False':
                tmpcount-=1
        
        if AllTorOneF == True:
            if tmpcount == 0:
                if not s[0][0] == 'g':
                    #if not len(SetOfTotalMapks) == 10000:
                    #    SetOfTotalMapks.append(s[0])
                    SetOfTotalMapks.append(s[0])
                    if len(SetOfTotalMapks)+len(SetOfTotalBapks) == 3500:
                        break
                else:
                    #if not len(SetOfTotalBapks) == 10000:
                    #    SetOfTotalBapks.append(s[0])
                    SetOfTotalBapks.append(s[0])
                    if len(SetOfTotalMapks)+len(SetOfTotalBapks) == 3500:
                        break
        else:
            if not tmpcount == noOffeattyps:
                if not s[0][0] == 'g':
                    #if not len(SetOfTotalMapks) == 10000:
                    #    SetOfTotalMapks.append(s[0])
                    SetOfTotalMapks.append(s[0])
                    if len(SetOfTotalMapks)+len(SetOfTotalBapks) == 3500:
                        break
                else:
                    #if not len(SetOfTotalBapks) == 10000:
                    #    SetOfTotalBapks.append(s[0])
                    SetOfTotalBapks.append(s[0])
                    if len(SetOfTotalMapks)+len(SetOfTotalBapks) == 3500:
                        break


    fposapks.close()

    with open(path)  as f:
        for line in f:
            
            if line.find('@relation')>-1 and line.find('@attribute')>-1:
                line = '@'+line.split('@')[2]
                
            if line.find('@attribute')>-1:
                s = line.split()
                if s[1].find('manifest_')>-1:
                    manifcount+=1
                elif s[1].find('string_')>-1:
                    strfcount+=1
                elif s[1].find('methodOP_')>-1:
                    methodOPfcount+=1
                elif s[1].find('methodAPI_')>-1:
                    methodAPIfcount+=1
                elif s[1].find('functionOP_')>-1:
                    funcOPfcount+=1
                elif s[1].find('functionSYS_')>-1:
                    funcSYSfcount+=1
                elif s[1].find('Img')>-1:
                    Imgfcount+=1
            elif line.find('@data')>-1:
                flag = True
                Mdataset = np.empty(len(SetOfTotalMapks)*(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1),dtype='float64')
                Bdataset = np.empty(len(SetOfTotalBapks)*(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1),dtype='float64')
                continue
            if flag == True:
                s = line.split(', ')
                i=0
                if s[-2] == 'M':
                    if s[-1][:-1] in SetOfTotalMapks:
                        for k in range(len(s[:-2])):
                            temp = s[k]
                            threshold = 5
                            if  manifcount+strfcount < k and k < manifcount+strfcount+methodOPfcount:
                                threshold = 2
                            elif  manifcount+strfcount+methodOPfcount < k and k < manifcount+strfcount+methodOPfcount+methodAPIfcount:
                                threshold = 5
                            elif manifcount+strfcount+methodOPfcount+methodAPIfcount < k and k < manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount:
                                threshold = 1
                            elif manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount < k and k < manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount:
                                threshold = 2
                            existsval = 0
                            if round(float(temp)*10) > threshold: #5-method
                                existsval = 1
                            if float(temp) > 1:
                                #Mdataset[mcount*(manifcount+strfcount+methodfcount+funcfcount+Imgfcount+1)+i] = round(float(1)*10)
                                Mdataset[mcount*(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1)+i] = 1
                            else:
                                #Mdataset[mcount*(manifcount+strfcount+methodfcount+funcfcount+Imgfcount+1)+i] = round(float(temp)*10)
                                Mdataset[mcount*(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1)+i] = existsval
                            i+=1
                        Mdataset[mcount*(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1)+i] = 0.0
                        Mapknames.append(s[:-1])
                        numMdata+=1
                        mcount+=1
                        #print('M feature vector' + str(mcount)+" loaded")
                if s[-2] == 'B':
                    if s[-1][:-1] in SetOfTotalBapks:
                        for k in range(len(s[:-2])):
                            temp = s[k]
                            threshold = 5
                            if  manifcount+strfcount < k and k < manifcount+strfcount+methodOPfcount:
                                threshold = 2
                            elif  manifcount+strfcount +methodOPfcount < k and k < manifcount+strfcount+methodOPfcount+methodAPIfcount:
                                threshold = 5
                            elif manifcount+strfcount+methodOPfcount+methodAPIfcount < k and k < manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount:
                                threshold = 1
                            elif manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount < k and k < manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount:
                                threshold = 2
                            existsval = 0
                            if round(float(temp)*10) > threshold:
                                existsval = 1
                            if float(temp) > 1:
                                #Bdataset[bcount*(manifcount+strfcount+methodfcount+funcfcount+Imgfcount+1)+i] = round(float(1)*10)
                                Bdataset[bcount*(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1)+i] = 1
                            else:
                                #Bdataset[bcount*(manifcount+strfcount+methodfcount+funcfcount+Imgfcount+1)+i] = round(float(temp)*10)
                                Bdataset[bcount*(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1)+i] = existsval
                            i+=1
                        Bdataset[bcount*(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1)+i] = 1.0
                        Bapknames.append(s[:-1])
                        numBdata+=1
                        bcount+=1
                        #print('B feature vector' + str(bcount)+" loaded")  

    featnos = list()
    featnos.append(manifcount)
    featnos.append(strfcount)
    featnos.append(methodOPfcount)
    featnos.append(methodAPIfcount)
    featnos.append(funcOPfcount)
    featnos.append(funcSYSfcount)

    Mdataset = np.reshape(Mdataset, (numMdata,(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1)))
    Bdataset = np.reshape(Bdataset, (numBdata,(manifcount+strfcount+methodOPfcount+methodAPIfcount+funcOPfcount+funcSYSfcount+Imgfcount+1)))

    return Mdataset, Bdataset, Mapknames, Bapknames, featnos



def divideTwoSets(Mdataset, Bdataset, testRatio=0.2):

    # input validation
    #if testRatio > 1 or testRatio < 0:
    #    print('testRatio shoul be 0<=ratio<=1')
    #    return -1

    if not  len(Mdataset) > 0:
        print('M not valid dataset')
        return -1
    if not  len(Bdataset) > 0:
        print('B not valid dataset')
        return -1

    Mindexlist = range(np.shape(Mdataset)[0])
    Bindexlist = range(np.shape(Bdataset)[0])

    mX_train, mX_test, mY_train, mY_test = train_test_split(Mdataset, Mindexlist, test_size=testRatio, random_state=42)
    bX_train, bX_test, bY_train, bY_test = train_test_split(Bdataset, Bindexlist, test_size=testRatio, random_state=42)

    return mX_train, mX_test, mY_train, mY_test, bX_train, bX_test, bY_train, bY_test


def normTwoSets(Mdataset, Bdataset):

    if not  len(Mdataset) > 0:
        print('M not valid dataset')
        return -1
    if not  len(Bdataset) > 0:
        print('B not valid dataset')
        return -1

    nocolm = len(Mdataset[0])-1
    norowM = len(Mdataset)
    norowB = len(Bdataset)

    mmaxs = np.zeros(nocolm)
    mmins = np.zeros(nocolm)
    bmaxs = np.zeros(nocolm)
    bmins = np.zeros(nocolm)
    Tmaxs = np.zeros(nocolm)
    Tmins = np.zeros(nocolm)

    Mtmpdataset = np.reshape(Mdataset,(nocolm+1,norowM))
    Btmpdataset = np.reshape(Bdataset,(nocolm+1,norowB))

    for i in range(nocolm):
        mmaxs[i] = np.nanmax(Mtmpdataset[i]) 
        mmins[i] = np.nanmin(Mtmpdataset[i]) 
        bmaxs[i] = np.nanmax(Btmpdataset[i]) 
        bmins[i] = np.nanmin(Btmpdataset[i]) 

        if mmaxs[i] > bmaxs[i]:
            Tmaxs[i] = mmaxs[i]
        else:
            Tmaxs[i] = bmaxs[i]
        if mmins[i] < bmins[i]:
            Tmins[i] = mmins[i]
        else:
            Tmins[i] = bmins[i]    

    for i in range(len(Mdataset)):
        for j in range(nocolm):
            Mdataset[i][j] = (Mdataset[i][j]-Tmins[i]) / (Tmaxs[i]-Tmins[i])
            Mdataset[i][j] = round(Mdataset[i][j])

    for i in range(len(Bdataset)):
        for j in range(nocolm):
            Bdataset[i][j] = (Bdataset[i][j]-Tmins[i]) / (Tmaxs[i]-Tmins[i])
            Bdataset[i][j] = round(Bdataset[i][j])

    return Mdataset, Bdataset




